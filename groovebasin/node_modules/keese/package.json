{
  "name": "keese",
  "version": "1.0.0",
  "description": "limited-functionality arbitrary-precision floats encoded as strings in javascript",
  "main": "index.js",
  "scripts": {
    "test": "node test.js"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/thejoshwolfe/node-keese.git"
  },
  "author": {
    "name": "Josh Wolfe",
    "email": "thejoshwolfe@gmail.com"
  },
  "license": "BSD",
  "readmeFilename": "readme.md",
  "readme": "node-keese\n==========\n\nGenerator for well-ordered values, appropriate for use as sorting keys.\n\nkeese can always generate a bigger value, a smaller value, and a value between two other values.\nThis is trivial using numbers with `x+1`, `x-1`, and `(x+y)/2` respectively.\nHowever, numbers have limited precision in JavaScript (see below), so instead keese uses strings.\n\nThe string values are comparable with the builtin comparison operators (such as `<`),\nand keese can *always* generate a new value that satisfies the constraints (limited only by system resources).\n\n```js\nvar keese = require('keese');\n\nvar something = keese();\nvar bigger = keese(something, null);\nvar smaller = keese(null, something);\n// smaller < something < bigger\nvar medium = keese(smaller, bigger);\n// smaller < medium < bigger\n// but no guarantee about middle vs something\n```\n\nFormally:\n\n```js\nvar middle = keese(low, high);\n```\n\nWhere:\n* `low` and `high` must each either be `== null` or be the result of a previous call to `keese`.\n* If `low` and `high` are both `== null`, then `middle` will be some arbitrary value to get you started.\n* If `low` is `!= null`, then `low` will be `< middle`.\n* If `high` is `!= null`, then `middle` will be `< high`.\n* If `low` and `high` are both `!= null`, then `low < middle < high` (so `low` must be `< high`).\n\n`keese` is a [pure function](http://en.wikipedia.org/wiki/Pure_function).\n\n\nWhy would I want this?\n----------------------\n\nSay you have a client-server architecture where clients can edit an ordered list of items.\nClients can insert, delete, and move items around in the list.\n([Groove Basin](https://github.com/superjoe30/groovebasin) does this with the current playlist of songs.)\n\nThe naive approach would be to use an Array, and communicate about where an operation is happening by using an index into the array.\nFor example, \"add item x at index 5\", or \"delete item at index 2\" or \"move item at index 7 to index 10\", etc.\nThis works well enough, but race conditions can cause sad behavior.\n\nImagine all three of the above commands are sent to the server at once from different clients.\nSay the server receives the \"delete\" command first, and shifts all the items above index 2 down 1.\nNow the \"move\" command referencing the item at index 7 is actually talking about a different item, one that was originally at index 8.\nThe \"add\" command is similarly misinterpreted, because the client may have specifically wanted \"item x\" to be inserted immediately after a particular item.\n\nAnother naive approach is to communicate about locations relative to existing items.\nFor example, \"add item x just after item y\", or \"delete item y\".\nDo you see the problem here?\nSay a client wants to insert \"item x\" in the middle of a range of 10 items, but another client deletes those 10 items before the insert request can be processed.\nThere's no guarantee that the item(s) a client refers to will still exist on the server by the time the request is processed.\n\nThe most robust solution is to communicate about locations using arbitrary sorting keys.\nGive every item a different value such that when the items are sorted using the values, they are ordered appropriately.\nFor example, start out by giving each of 10 items in the list the values 1 through 10 as their sorting keys.\n\nNow if a client deletes the item with the sorting key of 2, there's no need to shift anything; just leave the other sorting keys where they are.\nWhen a client wants to insert an item between 5 and 6, give the new item a sorting key of 5.5.\nWhen a client wants to move an item, change the items sorting key to some other value.\nAfter performing each of these operations, simply sort the list again, and the items will be in the desired order.\n\nBy using sorting keys, the opportunity for race conditions is almost entirely eliminated.\nThere can still be race conditions when there is truly no possible automatic solution,\nsuch as two clients inserting different items into the same location, or two clients both trying to delete the same item at once.\nHowever, these problems usually have trivial solutions, and they are outside the scope of this project.\n\nkeese exists for the purpose of generating sorting keys that never run out of precision.\n\n\nNumbers have limited precision\n------------------------------\n\nThis code snippet shows how many times you can obtain a middle value\nusing a JavaScript `Number` and still get a meaningful result.\n\n```js\nvar a = 1;\nvar b = 2;\nvar count = 0;\nwhile (a !== b) {\n  count += 1;\n  a = (a + b) / 2.0;\n}\nconsole.log(count);\n```\n\nOutput: 53\n\nComparing that to keese, we generate a middle value 53 times and then\ncheck the result.\n\n```js\nvar keese = require('keese');\nvar low = keese();\nvar high = keese(low, null);\nfor (var i = 0; i < 53; i += 1) {\n  high = keese(low, high);\n}\nconsole.log(high);\n```\n\nOutput: \"1000000002\"\n\nThis takes up a few more bytes than a `Number`. However, unlike what happens\nwhen you generate a middle value 53 times with a `Number`, we actually have\na usable value to compare.\n\n\nHow it works\n------------\n\nThe problem with JavaScript `Number`s is that they have limited precision.\nIn order to get arbitrary numeric precision, we need more than a single primitive number value;\nwe need an arbitrarily-large array of numbers.\nWe could use JavaScript `Array`s, but `String`s are better for the following reasons:\nstrings are more compact in JSON (and probably in memory),\nand strings can be compared easily with a builtin function (the `<` operator),\nwhich is convenient (and probably much more efficient that writing a custom Array comparator).\nBeing able to compare strings using `<` (called lexicographical ordering) is a driving principle in the design of this library.\n\nSo how do we encode arbitrary precision numbers in strings in such a way as to preserve lexicographical ordering?\nBase 10 is a good place to start.\nWhat comes between `\"0.1\"` and `\"0.2\"`?\nThe numeric answer `\"0.15\"` satisfies the lexicographical ordering;\nadding digits to the end of the smaller string is a good way to implement going in between two values.\n\nThe problem with a naive base 10 encoding is that adding digits to the left breaks lexicographical ordering.\n`9 < 10` but `\"9\" > \"10\"`.\nThe problem is that the \"ones\" digit `\"9\"` is being compared to the \"tens\" digit `\"1\"` in `\"10\"`.\nThe common way to solve this frame-shift error is to pad any small numbers with `\"0\"`s.\n`\"09\" < \"10\"`.\nThis is obviously problematic, because we are forced to limit the number of digits with this strategy, thereby failing to have arbitrary precision.\n\nThe solution is to reserve a special digit `\"~\"` that has a larger character value than any other character in the alphabet,\nand use this character to make sure we never get frame shift errors.\n`\"9\" < \"~10\"`. `\"~99\" < \"~~100\"`.\nIf two values have different orders of magnitude, then a `\"~\"` will inevitably be compared against a character that is not a `\"~\"`,\nand no actual digit values will ever be compared.\n(While this doubles the number of digits for large integers, remember that the number of digits is still O(n).)\n\nWith this lexicographically-correct magnitude specification, we have no need for any decimal points,\nwhich in common notation accomplish the same purpose.\nWe can write `\"21\"` instead of `\"2.1\"`, because we know that `\"~12\"` is bigger due to the `\"~\"`.\n\nOne last problem remains, which is how to generate a value smaller than the parameter.\nWe have no way of encoding negative numbers lexicographically correctly;\nall the digit values would be inverted, and comparisons would be all wrong.\nThe solution to this is surprisingly trivial;\nkeep a \"smallest value\" secret from the client,\nand implement the \"smaller\" function by going in between the \"smallest value\" and the parameter.\nWe reserve the number `0`, encoded as `\"\"`, as the smallest value, and effectively halve any parameter to generate a smaller value.\n\n(It would be more efficient to use a special character, such as `\"!\"`, to signify negative magnitude.\nOh well. Maybe in a future version of keese.)\n\nAs a matter of efficiency, using base 10 would only encode 10 values per character, but we can easily encode many more.\nJavaScript strings are made of 16-bit characters, so the maximum density we can achieve is radix 65536 (not counting the magnitude specifier).\nHowever, many characters in this range are unreadable and untypable,\nand some JSON libraries (such as in python) will escape non-ascii values with `\"\\x1234\"` notation by default,\nso radix 65536 may not be worth the trouble.\nFollowing the example of the base64 encoding, keese uses radix 64 with all printable ascii characters.\n\nThis is the alphabet:\n\n```\n0123456789?@ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\n```\n\nplus `\"~\"` for the magnitude specification.\n\nHere are some example encoded values:\n\n* `keese()` returns \"1\", the number `1`.\n* `\"z\"` is the number `63`.\n* `keese(\"z\", null)` returns \"~10\", the number `64`.\n* `keese(\"1\", \"2\")` returns \"1U\", the number `1.5`.\n\n\nAlgorithmic Complexity\n----------------------\n\nThe runtime performance of calling `keese` once is proportional to the size of the inputs.\nFormally, the runtime of `keese(low, high)` is `O(low.length + high.length)`.\n\nThe size of the return value depends on the value of the input parameters.\nInformally:\n* initializing: `keese()` is `O(1)`\n* increasing: `keese(low, null)` is `O(log(n))`\n* decreasing: `keese(null, high)` is `O(n)` (probably could be improved)\n* betweening: `keese(low, high)` is `O(n)`\n\nWhere `n` is how many times `keese` has been called to get the input value.\n\nMore formally, start with `var x = keese()`, run the below code,\nthen analyze the size of `x` in terms of `n`.\n\nIncreasing (`O(log(n))`):\n```js\nfor (var i = 0; i < n; i++) {\n  x = keese(x, null);\n}\n```\n\nDecreasing (`O(n)` - probably could be improved):\n```js\nfor (var i = 0; i < n; i++) {\n  x = keese(null, x);\n}\n```\n\nBetweening (`O(n)`):\n```js\nvar y = keese(x, null); // or any other value\nfor (var i = 0; i < n; i++) {\n  if (Math.random() > 0.5) {\n    x = keese(x, y);\n  } else {\n    y = keese(x, y);\n  }\n}\n```\n\nI believe it is provable that betweening cannot do any better than `O(n)`:\n* Each value returned from `keese(x, y)` could be assigned to either `x` or `y`.\n* The next call to `keese(x, y)` must return a value that takes into account whether `x` or `y` was chosen in the previous step.\n  Because of this, the return value effectively encodes the decision of whether `x` or `y` was chosen.\n* This information is not lost on the next call to `keese(x, y)`.\n  Therefore, a value obtained through the algorithm above must encode a complete history of each decision.\n* Each of the `n` decisions must occupy up a minimum of 1 bit of space in the string, therefore the size of the string is `O(n)`.\n\n",
  "bugs": {
    "url": "https://github.com/thejoshwolfe/node-keese/issues"
  },
  "homepage": "https://github.com/thejoshwolfe/node-keese",
  "_id": "keese@1.0.0",
  "_from": "keese@~1.0.0"
}
