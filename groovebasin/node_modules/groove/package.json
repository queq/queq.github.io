{
  "name": "groove",
  "version": "1.4.1",
  "description": "bindings to libgroove - generic music player library",
  "main": "lib/index.js",
  "author": {
    "name": "Andrew Kelley",
    "email": "superjoe30@gmail.com"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/andrewrk/node-groove"
  },
  "scripts": {
    "test": "node test/test.js",
    "install": "node-gyp rebuild"
  },
  "license": "BSD-2-Clause",
  "engines": {
    "node": ">=0.10.18"
  },
  "devDependencies": {
    "ncp": "~0.4.2",
    "tap": "~0.4.4"
  },
  "dependencies": {
    "bindings": "~1.1.1"
  },
  "gypfile": true,
  "readme": "# node-groove\n\nNode.js bindings to [libgroove](https://github.com/andrewrk/libgroove) -\ngeneric music player backend library.\n\nLive discussion in #libgroove IRC channel on irc.freenode.org.\n\n## Usage\n\n1. Install libgroove to your system.\n2. `npm install --save groove`\n\n### Get Metadata from File\n\n```js\nvar groove = require('groove');\n\ngroove.open(\"danse-macabre.ogg\", function(err, file) {\n  if (err) throw err;\n  console.log(file.metadata());\n  console.log(\"duration:\", file.duration());\n  file.close(function(err) {\n    if (err) throw err;\n  });\n});\n```\n\n#### More Examples\n\n * example/metadata.js - read or update metadata in a media file\n * example/playlist.js - play several files in a row and then exit\n * example/replaygain.js - compute replaygain values for media files\n * example/transcode.js - convert and splice several files together\n\n## API Documentation\n\n### globals\n\n#### groove.setLogging(level)\n\n`level` can be:\n\n * `groove.LOG_QUIET`\n * `groove.LOG_ERROR`\n * `groove.LOG_WARNING`\n * `groove.LOG_INFO`\n\n#### groove.loudnessToReplayGain(loudness)\n\nConverts a loudness value which is in LUFS to the ReplayGain-suggested dB\nadjustment.\n\n#### groove.dBToFloat(dB)\n\nConverts dB format volume adjustment to a floating point gain format.\n\n### GrooveFile\n\n#### groove.open(filename, callback)\n\n`callback(err, file)`\n\n#### file.close(callback)\n\n`callback(err)`\n\n#### file.duration()\n\nIn seconds.\n\n#### file.shortNames()\n\nA comma-separated list of short names for the format.\n\n#### file.getMetadata(key, [flags])\n\nFlags:\n\n * `groove.TAG_MATCH_CASE`\n * `groove.TAG_DONT_OVERWRITE`\n * `groove.TAG_APPEND`\n\n#### file.setMetadata(key, value, [flags])\n\nSee `getMetadata` for flags.\n\nPass `null` for `value` to delete a key.\n\n#### file.metadata()\n\nThis returns an object populated with all the metadata.\nUpdating the object does nothing. Use `setMetadata` to\nupdate metadata and then `save` to write changes to disk.\n\n#### file.dirty\n\nBoolean whether `save` will do anything.\n\n#### file.filename\n\nThe string that was passed to `groove.open`\n\n#### file.save(callback)\n\n`callback(err)`\n\n### GroovePlaylist\n\n#### groove.createPlaylist()\n\nA playlist managers keeping an audio buffer full. To send the buffer\nto your speakers, use `playlist.createPlayer()`.\n\n#### playlist.items()\n\nReturns a read-only array of playlist items.\nUse `playlist.insert` and `playlist.remove` to modify.\n\n`[playlistItem1, playlistItem2, ...]`\n\n#### playlist.play()\n\n#### playlist.pause()\n\n#### playlist.seek(playlistItem, position)\n\nSeek to `playlistItem`, `position` seconds into the song.\n\n#### playlist.insert(file, gain, nextPlaylistItem)\n\nCreates a new playlist item with file and puts it in the playlist before\n`nextPlaylistItem`. If `nextPlaylistItem` is `null`, appends the new\nitem to the playlist.\n\n`gain` is a float format volume adjustment that applies only to this item.\ndefaults to 1.0\n\nReturns the newly added playlist item.\n\nOnce you add a file to the playlist, you must not `file.close()` it until\nyou first remove it from the playlist.\n\n#### playlist.remove(playlistItem)\n\nRemove `playlistItem` from the playlist.\n\nNote that you are responsible for calling `file.close()` on every file\nthat you open with `groove.open`. `playlist.remove` will not close files.\n\n#### playlist.position()\n\nReturns `{item, pos}` where `item` is the playlist item currently being\ndecoded and `pos` is how many seconds into the song the decode head is.\n\nNote that typically you are more interested in the position of the play head,\nnot the decode head. Example methods which return the play head are\n`player.position()` and `encoder.position()`.\n\n#### playlist.playing()\n\nReturns `true` or `false`.\n\n#### playlist.clear()\n\nRemove all playlist items.\n\n#### playlist.count()\n\nHow many items are on the playlist.\n\n#### playlist.volume\n\n#### playlist.setVolume(value)\n\nBetween 0.0 and 1.0. You probably want to leave this at 1.0, since using\nreplaygain will typically lower your volume a significant amount.\n\n#### playlist.setItemGain(playlistItem, gain)\n\n`gain` is a float that affects the volume of the specified playlist item only.\nTo convert from dB to float, use exp(log(10) * 0.05 * dBValue).\n\n### GroovePlaylistItem\n\nThese are not instantiated directly; instead they are returned from\n`playlist.items()`.\n\n#### item.file\n\n#### item.gain\n\n#### item.id\n\nEvery time you obtain a playlist item from groove, you will get a fresh\nJavaScript object, but it might point to the same underlying libgroove pointer\nas another. The `id` field is a way to check if two playlist items reference\nthe same one.\n\n### GroovePlayer\n\n#### groove.getDevices()\n\nReturns an array of device names which are the devices you can send audio\nto.\n\n#### groove.createPlayer()\n\nCreates a GroovePlayer instance which you can then configure by setting\nproperties.\n\n#### player.deviceName\n\nBefore calling `attach()`, set this to one of the device names returned from\n`groove.getDevices()` or `null` to represent the default device.\n\n#### player.targetAudioFormat\n\nThe desired audio format settings with which to open the device.\n`groove.createPlayer()` defaults these to 44100 Hz,\nsigned 16-bit int, stereo.\nThese are preferences; if a setting cannot be used, a substitute will\nbe used instead. In this case, actualAudioFormat will be updated to reflect\nthe substituted values.\n\nProperties:\n\n * `sampleRate`\n * `channelLayout`\n * `sampleFormat`\n\n#### player.actualAudioFormat\n\ngroove sets this to the actual format you get when you open the device.\nIdeally will be the same as targetAudioFormat but might not be.\n\nProperties:\n\n * `sampleRate`\n * `channelLayout`\n * `sampleFormat`\n\n#### player.deviceBufferSize\n\nhow big the device buffer should be, in sample frames.\nmust be a power of 2.\n`groove.createPlayer()` defaults this to 1024\n\n#### player.sinkBufferSize\n\nHow big the sink buffer should be, in sample frames.\n`groove.createPlayer()` defaults this to 8192\n\n#### player.attach(playlist, callback)\n\nSends audio to sound device.\n\n`callback(err)`\n\n#### player.detach(callback)\n\n`callback(err)`\n\n#### player.position()\n\nReturns `{item, pos}` where `item` is the playlist item currently being\nplayed and `pos` is how many seconds into the song the play head is.\n\n#### player.on('nowplaying', handler)\n\nFires when the item that is now playing changes. It can be `null`.\n\n`handler()`\n\n#### player.on('bufferunderrun', handler)\n\nFires when a buffer underrun occurs. Ideally you'll never see this.\n\n`handler()`\n\n### GrooveEncoder\n\n#### groove.createEncoder()\n\n#### encoder.bitRate\n\nselect encoding quality by choosing a target bit rate\n\n#### encoder.formatShortName\n\noptional - help libgroove guess which format to use.\n`avconv -formats` to get a list of possibilities.\n\n#### encoder.codecShortName\n\noptional - help libgroove guess which codec to use.\n`avconv-codecs` to get a list of possibilities.\n\n#### encoder.filename\n\noptional - provide an example filename to help libgroove guess\nwhich format/codec to use.\n\n#### encoder.mimeType\n\noptional - provide a mime type string to help libgrooove guess\nwhich format/codec to use.\n\n#### encoder.attach(playlist, callback)\n\n`callback(err)`\n\n#### encoder.detach(callback)\n\n`callback(err)`\n\n#### encoder.getBuffer()\n\nReturns `null` if no buffer available, or an object with these properties:\n\n * `buffer` - a node `Buffer` instance which is the encoded data for this chunk\n   this can be `null` in which case this buffer is actually the end of\n   playlist sentinel.\n * `item` - the GroovePlaylistItem of which this buffer is encoded data for\n * `pos` - position in seconds that this buffer represents in into the item\n\n#### encoder.on('buffer', handler)\n\n`handler()`\n\nEmitted when there is a buffer available to get. You still need to get the\nbuffer with `getBuffer()`.\n\n#### encoder.position()\n\nReturns `{item, pos}` where `item` is the playlist item currently being\nencoded and `pos` is how many seconds into the song the encode head is.\n\n### GrooveLoudnessDetector\n\n#### groove.createLoudnessDetector()\n\nreturns a GrooveLoudnessDetector\n\n#### detector.infoQueueSize\n\nSet this to determine how far ahead into the playlist to look.\n\n#### detector.sinkBufferSize\n\nHow big the sink buffer should be, in sample frames.\n`groove.createLoudnessDetector()` defaults this to 8192\n\n#### detector.disableAlbum\n\nSet to `true` to only compute track loudness. This is faster and requires less\nmemory than computing both.\n\n#### detector.attach(playlist, callback)\n\n`callback(err)`\n\n#### detector.detach(callback)\n\n`callback(err)`\n\n#### detector.getInfo()\n\nReturns `null` if no info available, or an object with these properties:\n\n * `loudness` - loudness in LUFS\n * `peak` - sample peak in float format of the file\n * `duration` - duration in seconds of the track\n * `item` - the GroovePlaylistItem that this applies to, or `null` if it applies\n   to the entire album.\n\n#### detector.position()\n\nReturns `{item, pos}` where `item` is the playlist item currently being\ndetected and `pos` is how many seconds into the song the detect head is.\n\n#### detector.on('info', handler)\n\n`handler()`\n\nEmitted when there is info available to get. You still need to get the info\nwith `getInfo()`.\n\n### GrooveFingerprinter\n\n#### groove.createFingerprinter()\n\nreturns a GrooveFingerprinter\n\n#### groove.encodeFingerprint(rawFingerprint)\n\nGiven an Array of integers which is the raw fingerprint, encode it into a\nstring which can be submitted to acoustid.org.\n\n#### groove.decodeFingerprint(fingerprint)\n\nGiven the fingerprint string, returns a list of integers which is the raw\nfingerprint data.\n\n#### printer.infoQueueSize\n\nSet this to determine how far ahead into the playlist to look.\n\n#### printer.sinkBufferSize\n\nHow big the sink buffer should be, in sample frames.\n`groove.createFingerprinter()` defaults this to 8192\n\n#### printer.attach(playlist, callback)\n\n`callback(err)`\n\n#### printer.detach(callback)\n\n`callback(err)`\n\n#### printer.getInfo()\n\nReturns `null` if no info available, or an object with these properties:\n\n * `fingerprint` - string encoded fingerprint which you can submit to acoustid.org.\n * `duration` - duration in seconds of the track\n * `item` - the GroovePlaylistItem that this applies to, or `null` if it applies\n   to the entire album.\n\n#### printer.position()\n\nReturns `{item, pos}` where `item` is the playlist item currently being\nfingerprinted and `pos` is how many seconds into the song the printer head is.\n\n#### printer.on('info', handler)\n\n`handler()`\n\nEmitted when there is info available to get. You still need to get the info\nwith `getInfo()`.\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/andrewrk/node-groove/issues"
  },
  "homepage": "https://github.com/andrewrk/node-groove",
  "_id": "groove@1.4.1",
  "_from": "groove@~1.4.1"
}
